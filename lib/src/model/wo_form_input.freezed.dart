// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'wo_form_input.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$WoFormInputError {

 String get path;
/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WoFormInputErrorCopyWith<WoFormInputError> get copyWith => _$WoFormInputErrorCopyWithImpl<WoFormInputError>(this as WoFormInputError, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WoFormInputError&&(identical(other.path, path) || other.path == path));
}


@override
int get hashCode => Object.hash(runtimeType,path);

@override
String toString() {
  return 'WoFormInputError(path: $path)';
}


}

/// @nodoc
abstract mixin class $WoFormInputErrorCopyWith<$Res>  {
  factory $WoFormInputErrorCopyWith(WoFormInputError value, $Res Function(WoFormInputError) _then) = _$WoFormInputErrorCopyWithImpl;
@useResult
$Res call({
 String path
});




}
/// @nodoc
class _$WoFormInputErrorCopyWithImpl<$Res>
    implements $WoFormInputErrorCopyWith<$Res> {
  _$WoFormInputErrorCopyWithImpl(this._self, this._then);

  final WoFormInputError _self;
  final $Res Function(WoFormInputError) _then;

/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? path = null,}) {
  return _then(_self.copyWith(
path: null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc


class EmptyInputError implements WoFormInputError {
  const EmptyInputError({required this.path});
  

@override final  String path;

/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$EmptyInputErrorCopyWith<EmptyInputError> get copyWith => _$EmptyInputErrorCopyWithImpl<EmptyInputError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is EmptyInputError&&(identical(other.path, path) || other.path == path));
}


@override
int get hashCode => Object.hash(runtimeType,path);

@override
String toString() {
  return 'WoFormInputError.empty(path: $path)';
}


}

/// @nodoc
abstract mixin class $EmptyInputErrorCopyWith<$Res> implements $WoFormInputErrorCopyWith<$Res> {
  factory $EmptyInputErrorCopyWith(EmptyInputError value, $Res Function(EmptyInputError) _then) = _$EmptyInputErrorCopyWithImpl;
@override @useResult
$Res call({
 String path
});




}
/// @nodoc
class _$EmptyInputErrorCopyWithImpl<$Res>
    implements $EmptyInputErrorCopyWith<$Res> {
  _$EmptyInputErrorCopyWithImpl(this._self, this._then);

  final EmptyInputError _self;
  final $Res Function(EmptyInputError) _then;

/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? path = null,}) {
  return _then(EmptyInputError(
path: null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class InvalidInputError implements WoFormInputError {
  const InvalidInputError({required this.path});
  

@override final  String path;

/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InvalidInputErrorCopyWith<InvalidInputError> get copyWith => _$InvalidInputErrorCopyWithImpl<InvalidInputError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InvalidInputError&&(identical(other.path, path) || other.path == path));
}


@override
int get hashCode => Object.hash(runtimeType,path);

@override
String toString() {
  return 'WoFormInputError.invalid(path: $path)';
}


}

/// @nodoc
abstract mixin class $InvalidInputErrorCopyWith<$Res> implements $WoFormInputErrorCopyWith<$Res> {
  factory $InvalidInputErrorCopyWith(InvalidInputError value, $Res Function(InvalidInputError) _then) = _$InvalidInputErrorCopyWithImpl;
@override @useResult
$Res call({
 String path
});




}
/// @nodoc
class _$InvalidInputErrorCopyWithImpl<$Res>
    implements $InvalidInputErrorCopyWith<$Res> {
  _$InvalidInputErrorCopyWithImpl(this._self, this._then);

  final InvalidInputError _self;
  final $Res Function(InvalidInputError) _then;

/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? path = null,}) {
  return _then(InvalidInputError(
path: null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class MaxBoundInputError implements WoFormInputError {
  const MaxBoundInputError({required this.path});
  

@override final  String path;

/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MaxBoundInputErrorCopyWith<MaxBoundInputError> get copyWith => _$MaxBoundInputErrorCopyWithImpl<MaxBoundInputError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MaxBoundInputError&&(identical(other.path, path) || other.path == path));
}


@override
int get hashCode => Object.hash(runtimeType,path);

@override
String toString() {
  return 'WoFormInputError.maxBound(path: $path)';
}


}

/// @nodoc
abstract mixin class $MaxBoundInputErrorCopyWith<$Res> implements $WoFormInputErrorCopyWith<$Res> {
  factory $MaxBoundInputErrorCopyWith(MaxBoundInputError value, $Res Function(MaxBoundInputError) _then) = _$MaxBoundInputErrorCopyWithImpl;
@override @useResult
$Res call({
 String path
});




}
/// @nodoc
class _$MaxBoundInputErrorCopyWithImpl<$Res>
    implements $MaxBoundInputErrorCopyWith<$Res> {
  _$MaxBoundInputErrorCopyWithImpl(this._self, this._then);

  final MaxBoundInputError _self;
  final $Res Function(MaxBoundInputError) _then;

/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? path = null,}) {
  return _then(MaxBoundInputError(
path: null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class MinBoundInputError implements WoFormInputError {
  const MinBoundInputError({required this.path});
  

@override final  String path;

/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MinBoundInputErrorCopyWith<MinBoundInputError> get copyWith => _$MinBoundInputErrorCopyWithImpl<MinBoundInputError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MinBoundInputError&&(identical(other.path, path) || other.path == path));
}


@override
int get hashCode => Object.hash(runtimeType,path);

@override
String toString() {
  return 'WoFormInputError.minBound(path: $path)';
}


}

/// @nodoc
abstract mixin class $MinBoundInputErrorCopyWith<$Res> implements $WoFormInputErrorCopyWith<$Res> {
  factory $MinBoundInputErrorCopyWith(MinBoundInputError value, $Res Function(MinBoundInputError) _then) = _$MinBoundInputErrorCopyWithImpl;
@override @useResult
$Res call({
 String path
});




}
/// @nodoc
class _$MinBoundInputErrorCopyWithImpl<$Res>
    implements $MinBoundInputErrorCopyWith<$Res> {
  _$MinBoundInputErrorCopyWithImpl(this._self, this._then);

  final MinBoundInputError _self;
  final $Res Function(MinBoundInputError) _then;

/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? path = null,}) {
  return _then(MinBoundInputError(
path: null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class CustomInputError implements WoFormInputError {
  const CustomInputError({required this.path, required this.message});
  

@override final  String path;
 final  String message;

/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CustomInputErrorCopyWith<CustomInputError> get copyWith => _$CustomInputErrorCopyWithImpl<CustomInputError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CustomInputError&&(identical(other.path, path) || other.path == path)&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,path,message);

@override
String toString() {
  return 'WoFormInputError.custom(path: $path, message: $message)';
}


}

/// @nodoc
abstract mixin class $CustomInputErrorCopyWith<$Res> implements $WoFormInputErrorCopyWith<$Res> {
  factory $CustomInputErrorCopyWith(CustomInputError value, $Res Function(CustomInputError) _then) = _$CustomInputErrorCopyWithImpl;
@override @useResult
$Res call({
 String path, String message
});




}
/// @nodoc
class _$CustomInputErrorCopyWithImpl<$Res>
    implements $CustomInputErrorCopyWith<$Res> {
  _$CustomInputErrorCopyWithImpl(this._self, this._then);

  final CustomInputError _self;
  final $Res Function(CustomInputError) _then;

/// Create a copy of WoFormInputError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? path = null,Object? message = null,}) {
  return _then(CustomInputError(
path: null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

WoFormInput _$WoFormInputFromJson(
  Map<String, dynamic> json
) {
        switch (json['runtimeType']) {
                  case 'boolean':
          return BooleanInput.fromJson(
            json
          );
                case 'dateTime':
          return DateTimeInput.fromJson(
            json
          );
                case 'duration':
          return DurationInput.fromJson(
            json
          );
                case 'media':
          return MediaInput.fromJson(
            json
          );
                case 'num':
          return NumInput.fromJson(
            json
          );
                case 'selectString':
          return SelectStringInput.fromJson(
            json
          );
                case 'string':
          return StringInput.fromJson(
            json
          );
        
          default:
            throw CheckedFromJsonException(
  json,
  'runtimeType',
  'WoFormInput',
  'Invalid union type "${json['runtimeType']}"!'
);
        }
      
}

/// @nodoc
mixin _$WoFormInput {

 String get id;@notSerializable WoFormInputError? Function(Never, String)? get getCustomError;@JsonKey(toJson: BooleanInputUiSettings.staticToJson)@JsonKey(toJson: DateTimeInputUiSettings.staticToJson)@JsonKey(toJson: DurationInputUiSettings.staticToJson)@JsonKey(toJson: MediaInputUiSettings.staticToJson)@JsonKey(toJson: _SelectInputUiSettingsX.staticToJsonString)@JsonKey(toJson: StringInputUiSettings.staticToJson) Object get uiSettings;
/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WoFormInputCopyWith<WoFormInput> get copyWith => _$WoFormInputCopyWithImpl<WoFormInput>(this as WoFormInput, _$identity);

  /// Serializes this WoFormInput to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WoFormInput&&(identical(other.id, id) || other.id == id)&&(identical(other.getCustomError, getCustomError) || other.getCustomError == getCustomError)&&const DeepCollectionEquality().equals(other.uiSettings, uiSettings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,getCustomError,const DeepCollectionEquality().hash(uiSettings));

@override
String toString() {
  return 'WoFormInput(id: $id, getCustomError: $getCustomError, uiSettings: $uiSettings)';
}


}

/// @nodoc
abstract mixin class $WoFormInputCopyWith<$Res>  {
  factory $WoFormInputCopyWith(WoFormInput value, $Res Function(WoFormInput) _then) = _$WoFormInputCopyWithImpl;
@useResult
$Res call({
 String id
});




}
/// @nodoc
class _$WoFormInputCopyWithImpl<$Res>
    implements $WoFormInputCopyWith<$Res> {
  _$WoFormInputCopyWithImpl(this._self, this._then);

  final WoFormInput _self;
  final $Res Function(WoFormInput) _then;

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class BooleanInput extends WoFormInput {
  const BooleanInput({required this.id, this.initialValue, this.isRequired = false, @notSerializable this.getCustomError, @notSerializable this.onValueChanged, @JsonKey(toJson: BooleanInputUiSettings.staticToJson) this.uiSettings = const BooleanInputUiSettings(), final  String? $type}): $type = $type ?? 'boolean',super._();
  factory BooleanInput.fromJson(Map<String, dynamic> json) => _$BooleanInputFromJson(json);

@override final  String id;
 final  bool? initialValue;
@JsonKey() final  bool isRequired;
@override@notSerializable final  GetCustomErrorDef<bool>? getCustomError;
/// An optionnal callback when the value changed
@notSerializable final  void Function(bool? value)? onValueChanged;
@override@JsonKey(toJson: BooleanInputUiSettings.staticToJson) final  BooleanInputUiSettings uiSettings;

@JsonKey(name: 'runtimeType')
final String $type;


/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BooleanInputCopyWith<BooleanInput> get copyWith => _$BooleanInputCopyWithImpl<BooleanInput>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$BooleanInputToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BooleanInput&&(identical(other.id, id) || other.id == id)&&(identical(other.initialValue, initialValue) || other.initialValue == initialValue)&&(identical(other.isRequired, isRequired) || other.isRequired == isRequired)&&(identical(other.getCustomError, getCustomError) || other.getCustomError == getCustomError)&&(identical(other.onValueChanged, onValueChanged) || other.onValueChanged == onValueChanged)&&(identical(other.uiSettings, uiSettings) || other.uiSettings == uiSettings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,initialValue,isRequired,getCustomError,onValueChanged,uiSettings);

@override
String toString() {
  return 'WoFormInput.boolean(id: $id, initialValue: $initialValue, isRequired: $isRequired, getCustomError: $getCustomError, onValueChanged: $onValueChanged, uiSettings: $uiSettings)';
}


}

/// @nodoc
abstract mixin class $BooleanInputCopyWith<$Res> implements $WoFormInputCopyWith<$Res> {
  factory $BooleanInputCopyWith(BooleanInput value, $Res Function(BooleanInput) _then) = _$BooleanInputCopyWithImpl;
@override @useResult
$Res call({
 String id, bool? initialValue, bool isRequired,@notSerializable GetCustomErrorDef<bool>? getCustomError,@notSerializable void Function(bool? value)? onValueChanged,@JsonKey(toJson: BooleanInputUiSettings.staticToJson) BooleanInputUiSettings uiSettings
});


$BooleanInputUiSettingsCopyWith<$Res> get uiSettings;

}
/// @nodoc
class _$BooleanInputCopyWithImpl<$Res>
    implements $BooleanInputCopyWith<$Res> {
  _$BooleanInputCopyWithImpl(this._self, this._then);

  final BooleanInput _self;
  final $Res Function(BooleanInput) _then;

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? initialValue = freezed,Object? isRequired = null,Object? getCustomError = freezed,Object? onValueChanged = freezed,Object? uiSettings = null,}) {
  return _then(BooleanInput(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,initialValue: freezed == initialValue ? _self.initialValue : initialValue // ignore: cast_nullable_to_non_nullable
as bool?,isRequired: null == isRequired ? _self.isRequired : isRequired // ignore: cast_nullable_to_non_nullable
as bool,getCustomError: freezed == getCustomError ? _self.getCustomError : getCustomError // ignore: cast_nullable_to_non_nullable
as GetCustomErrorDef<bool>?,onValueChanged: freezed == onValueChanged ? _self.onValueChanged : onValueChanged // ignore: cast_nullable_to_non_nullable
as void Function(bool? value)?,uiSettings: null == uiSettings ? _self.uiSettings : uiSettings // ignore: cast_nullable_to_non_nullable
as BooleanInputUiSettings,
  ));
}

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BooleanInputUiSettingsCopyWith<$Res> get uiSettings {
  
  return $BooleanInputUiSettingsCopyWith<$Res>(_self.uiSettings, (value) {
    return _then(_self.copyWith(uiSettings: value));
  });
}
}

/// @nodoc
@JsonSerializable()

class DateTimeInput extends WoFormInput {
  const DateTimeInput({required this.id, @JsonKey(toJson: FlexibleDateTime.staticToJson) this.initialValue, this.isRequired = false, @JsonKey(toJson: FlexibleDateTime.staticToJson) this.maxDate, @JsonKey(toJson: FlexibleDateTime.staticToJson) this.minDate, @notSerializable this.getCustomError, @JsonKey(toJson: DateTimeInputUiSettings.staticToJson) this.uiSettings = const DateTimeInputUiSettings(), final  String? $type}): $type = $type ?? 'dateTime',super._();
  factory DateTimeInput.fromJson(Map<String, dynamic> json) => _$DateTimeInputFromJson(json);

@override final  String id;
@JsonKey(toJson: FlexibleDateTime.staticToJson) final  FlexibleDateTime? initialValue;
@JsonKey() final  bool isRequired;
@JsonKey(toJson: FlexibleDateTime.staticToJson) final  FlexibleDateTime? maxDate;
@JsonKey(toJson: FlexibleDateTime.staticToJson) final  FlexibleDateTime? minDate;
@override@notSerializable final  GetCustomErrorDef<DateTime>? getCustomError;
@override@JsonKey(toJson: DateTimeInputUiSettings.staticToJson) final  DateTimeInputUiSettings uiSettings;

@JsonKey(name: 'runtimeType')
final String $type;


/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DateTimeInputCopyWith<DateTimeInput> get copyWith => _$DateTimeInputCopyWithImpl<DateTimeInput>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DateTimeInputToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DateTimeInput&&(identical(other.id, id) || other.id == id)&&(identical(other.initialValue, initialValue) || other.initialValue == initialValue)&&(identical(other.isRequired, isRequired) || other.isRequired == isRequired)&&(identical(other.maxDate, maxDate) || other.maxDate == maxDate)&&(identical(other.minDate, minDate) || other.minDate == minDate)&&(identical(other.getCustomError, getCustomError) || other.getCustomError == getCustomError)&&(identical(other.uiSettings, uiSettings) || other.uiSettings == uiSettings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,initialValue,isRequired,maxDate,minDate,getCustomError,uiSettings);

@override
String toString() {
  return 'WoFormInput.dateTime(id: $id, initialValue: $initialValue, isRequired: $isRequired, maxDate: $maxDate, minDate: $minDate, getCustomError: $getCustomError, uiSettings: $uiSettings)';
}


}

/// @nodoc
abstract mixin class $DateTimeInputCopyWith<$Res> implements $WoFormInputCopyWith<$Res> {
  factory $DateTimeInputCopyWith(DateTimeInput value, $Res Function(DateTimeInput) _then) = _$DateTimeInputCopyWithImpl;
@override @useResult
$Res call({
 String id,@JsonKey(toJson: FlexibleDateTime.staticToJson) FlexibleDateTime? initialValue, bool isRequired,@JsonKey(toJson: FlexibleDateTime.staticToJson) FlexibleDateTime? maxDate,@JsonKey(toJson: FlexibleDateTime.staticToJson) FlexibleDateTime? minDate,@notSerializable GetCustomErrorDef<DateTime>? getCustomError,@JsonKey(toJson: DateTimeInputUiSettings.staticToJson) DateTimeInputUiSettings uiSettings
});


$FlexibleDateTimeCopyWith<$Res>? get initialValue;$FlexibleDateTimeCopyWith<$Res>? get maxDate;$FlexibleDateTimeCopyWith<$Res>? get minDate;$DateTimeInputUiSettingsCopyWith<$Res> get uiSettings;

}
/// @nodoc
class _$DateTimeInputCopyWithImpl<$Res>
    implements $DateTimeInputCopyWith<$Res> {
  _$DateTimeInputCopyWithImpl(this._self, this._then);

  final DateTimeInput _self;
  final $Res Function(DateTimeInput) _then;

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? initialValue = freezed,Object? isRequired = null,Object? maxDate = freezed,Object? minDate = freezed,Object? getCustomError = freezed,Object? uiSettings = null,}) {
  return _then(DateTimeInput(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,initialValue: freezed == initialValue ? _self.initialValue : initialValue // ignore: cast_nullable_to_non_nullable
as FlexibleDateTime?,isRequired: null == isRequired ? _self.isRequired : isRequired // ignore: cast_nullable_to_non_nullable
as bool,maxDate: freezed == maxDate ? _self.maxDate : maxDate // ignore: cast_nullable_to_non_nullable
as FlexibleDateTime?,minDate: freezed == minDate ? _self.minDate : minDate // ignore: cast_nullable_to_non_nullable
as FlexibleDateTime?,getCustomError: freezed == getCustomError ? _self.getCustomError : getCustomError // ignore: cast_nullable_to_non_nullable
as GetCustomErrorDef<DateTime>?,uiSettings: null == uiSettings ? _self.uiSettings : uiSettings // ignore: cast_nullable_to_non_nullable
as DateTimeInputUiSettings,
  ));
}

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FlexibleDateTimeCopyWith<$Res>? get initialValue {
    if (_self.initialValue == null) {
    return null;
  }

  return $FlexibleDateTimeCopyWith<$Res>(_self.initialValue!, (value) {
    return _then(_self.copyWith(initialValue: value));
  });
}/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FlexibleDateTimeCopyWith<$Res>? get maxDate {
    if (_self.maxDate == null) {
    return null;
  }

  return $FlexibleDateTimeCopyWith<$Res>(_self.maxDate!, (value) {
    return _then(_self.copyWith(maxDate: value));
  });
}/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FlexibleDateTimeCopyWith<$Res>? get minDate {
    if (_self.minDate == null) {
    return null;
  }

  return $FlexibleDateTimeCopyWith<$Res>(_self.minDate!, (value) {
    return _then(_self.copyWith(minDate: value));
  });
}/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DateTimeInputUiSettingsCopyWith<$Res> get uiSettings {
  
  return $DateTimeInputUiSettingsCopyWith<$Res>(_self.uiSettings, (value) {
    return _then(_self.copyWith(uiSettings: value));
  });
}
}

/// @nodoc
@JsonSerializable()

class DurationInput extends WoFormInput {
  const DurationInput({required this.id, @DurationNullableConverter() this.initialValue, this.isRequired = false, this.startDatePath, @DurationNullableConverter() this.maxDuration, @DurationNullableConverter() this.minDuration, @notSerializable this.getCustomError, @JsonKey(toJson: DurationInputUiSettings.staticToJson) this.uiSettings = const DurationInputUiSettings(), final  String? $type}): $type = $type ?? 'duration',super._();
  factory DurationInput.fromJson(Map<String, dynamic> json) => _$DurationInputFromJson(json);

@override final  String id;
@DurationNullableConverter() final  Duration? initialValue;
@JsonKey() final  bool isRequired;
/// If provided, this should point to a DateTime in the WoFormValuesCubit.
/// When provided, the user will be able to choose between
/// DurationEditMode.dateTime and DurationEditMode.duration.
 final  String? startDatePath;
@DurationNullableConverter() final  Duration? maxDuration;
@DurationNullableConverter() final  Duration? minDuration;
@override@notSerializable final  GetCustomErrorDef<Duration>? getCustomError;
@override@JsonKey(toJson: DurationInputUiSettings.staticToJson) final  DurationInputUiSettings uiSettings;

@JsonKey(name: 'runtimeType')
final String $type;


/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DurationInputCopyWith<DurationInput> get copyWith => _$DurationInputCopyWithImpl<DurationInput>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DurationInputToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DurationInput&&(identical(other.id, id) || other.id == id)&&(identical(other.initialValue, initialValue) || other.initialValue == initialValue)&&(identical(other.isRequired, isRequired) || other.isRequired == isRequired)&&(identical(other.startDatePath, startDatePath) || other.startDatePath == startDatePath)&&(identical(other.maxDuration, maxDuration) || other.maxDuration == maxDuration)&&(identical(other.minDuration, minDuration) || other.minDuration == minDuration)&&(identical(other.getCustomError, getCustomError) || other.getCustomError == getCustomError)&&(identical(other.uiSettings, uiSettings) || other.uiSettings == uiSettings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,initialValue,isRequired,startDatePath,maxDuration,minDuration,getCustomError,uiSettings);

@override
String toString() {
  return 'WoFormInput.duration(id: $id, initialValue: $initialValue, isRequired: $isRequired, startDatePath: $startDatePath, maxDuration: $maxDuration, minDuration: $minDuration, getCustomError: $getCustomError, uiSettings: $uiSettings)';
}


}

/// @nodoc
abstract mixin class $DurationInputCopyWith<$Res> implements $WoFormInputCopyWith<$Res> {
  factory $DurationInputCopyWith(DurationInput value, $Res Function(DurationInput) _then) = _$DurationInputCopyWithImpl;
@override @useResult
$Res call({
 String id,@DurationNullableConverter() Duration? initialValue, bool isRequired, String? startDatePath,@DurationNullableConverter() Duration? maxDuration,@DurationNullableConverter() Duration? minDuration,@notSerializable GetCustomErrorDef<Duration>? getCustomError,@JsonKey(toJson: DurationInputUiSettings.staticToJson) DurationInputUiSettings uiSettings
});


$DurationInputUiSettingsCopyWith<$Res> get uiSettings;

}
/// @nodoc
class _$DurationInputCopyWithImpl<$Res>
    implements $DurationInputCopyWith<$Res> {
  _$DurationInputCopyWithImpl(this._self, this._then);

  final DurationInput _self;
  final $Res Function(DurationInput) _then;

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? initialValue = freezed,Object? isRequired = null,Object? startDatePath = freezed,Object? maxDuration = freezed,Object? minDuration = freezed,Object? getCustomError = freezed,Object? uiSettings = null,}) {
  return _then(DurationInput(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,initialValue: freezed == initialValue ? _self.initialValue : initialValue // ignore: cast_nullable_to_non_nullable
as Duration?,isRequired: null == isRequired ? _self.isRequired : isRequired // ignore: cast_nullable_to_non_nullable
as bool,startDatePath: freezed == startDatePath ? _self.startDatePath : startDatePath // ignore: cast_nullable_to_non_nullable
as String?,maxDuration: freezed == maxDuration ? _self.maxDuration : maxDuration // ignore: cast_nullable_to_non_nullable
as Duration?,minDuration: freezed == minDuration ? _self.minDuration : minDuration // ignore: cast_nullable_to_non_nullable
as Duration?,getCustomError: freezed == getCustomError ? _self.getCustomError : getCustomError // ignore: cast_nullable_to_non_nullable
as GetCustomErrorDef<Duration>?,uiSettings: null == uiSettings ? _self.uiSettings : uiSettings // ignore: cast_nullable_to_non_nullable
as DurationInputUiSettings,
  ));
}

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DurationInputUiSettingsCopyWith<$Res> get uiSettings {
  
  return $DurationInputUiSettingsCopyWith<$Res>(_self.uiSettings, (value) {
    return _then(_self.copyWith(uiSettings: value));
  });
}
}

/// @nodoc
@JsonSerializable()

class MediaInput extends WoFormInput {
  const MediaInput({required this.id, @JsonKey(toJson: MediaImportSettings.staticToJson) required this.importSettings, required this.maxCount, this.minCount = 0, @MediaListConverter() final  List<Media>? initialValues, @notSerializable this.getCustomError, @notSerializable this.onValueChanged, this.submitFormOnSelect = false, this.uploadPath, @JsonKey(toJson: MediaInputUiSettings.staticToJson) this.uiSettings = const MediaInputUiSettings(), final  String? $type}): assert(maxCount == null || minCount <= maxCount, 'maxCount must be higher or equal to minCount'),_initialValues = initialValues,$type = $type ?? 'media',super._();
  factory MediaInput.fromJson(Map<String, dynamic> json) => _$MediaInputFromJson(json);

@override final  String id;
@JsonKey(toJson: MediaImportSettings.staticToJson) final  MediaImportSettings importSettings;
 final  int? maxCount;
@JsonKey() final  int minCount;
 final  List<Media>? _initialValues;
@MediaListConverter() List<Media>? get initialValues {
  final value = _initialValues;
  if (value == null) return null;
  if (_initialValues is EqualUnmodifiableListView) return _initialValues;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override@notSerializable final  GetCustomErrorForListDef<Media>? getCustomError;
/// An optionnal callback when the value changed
@notSerializable final  void Function(List<Media>? value)? onValueChanged;
/// Only applies if maxCount is 1
@JsonKey() final  bool submitFormOnSelect;
/// Required if you use MediaInput.export()
 final  String? uploadPath;
@override@JsonKey(toJson: MediaInputUiSettings.staticToJson) final  MediaInputUiSettings uiSettings;

@JsonKey(name: 'runtimeType')
final String $type;


/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MediaInputCopyWith<MediaInput> get copyWith => _$MediaInputCopyWithImpl<MediaInput>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MediaInputToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MediaInput&&(identical(other.id, id) || other.id == id)&&(identical(other.importSettings, importSettings) || other.importSettings == importSettings)&&(identical(other.maxCount, maxCount) || other.maxCount == maxCount)&&(identical(other.minCount, minCount) || other.minCount == minCount)&&const DeepCollectionEquality().equals(other._initialValues, _initialValues)&&(identical(other.getCustomError, getCustomError) || other.getCustomError == getCustomError)&&(identical(other.onValueChanged, onValueChanged) || other.onValueChanged == onValueChanged)&&(identical(other.submitFormOnSelect, submitFormOnSelect) || other.submitFormOnSelect == submitFormOnSelect)&&(identical(other.uploadPath, uploadPath) || other.uploadPath == uploadPath)&&(identical(other.uiSettings, uiSettings) || other.uiSettings == uiSettings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,importSettings,maxCount,minCount,const DeepCollectionEquality().hash(_initialValues),getCustomError,onValueChanged,submitFormOnSelect,uploadPath,uiSettings);

@override
String toString() {
  return 'WoFormInput.media(id: $id, importSettings: $importSettings, maxCount: $maxCount, minCount: $minCount, initialValues: $initialValues, getCustomError: $getCustomError, onValueChanged: $onValueChanged, submitFormOnSelect: $submitFormOnSelect, uploadPath: $uploadPath, uiSettings: $uiSettings)';
}


}

/// @nodoc
abstract mixin class $MediaInputCopyWith<$Res> implements $WoFormInputCopyWith<$Res> {
  factory $MediaInputCopyWith(MediaInput value, $Res Function(MediaInput) _then) = _$MediaInputCopyWithImpl;
@override @useResult
$Res call({
 String id,@JsonKey(toJson: MediaImportSettings.staticToJson) MediaImportSettings importSettings, int? maxCount, int minCount,@MediaListConverter() List<Media>? initialValues,@notSerializable GetCustomErrorForListDef<Media>? getCustomError,@notSerializable void Function(List<Media>? value)? onValueChanged, bool submitFormOnSelect, String? uploadPath,@JsonKey(toJson: MediaInputUiSettings.staticToJson) MediaInputUiSettings uiSettings
});


$MediaImportSettingsCopyWith<$Res> get importSettings;$MediaInputUiSettingsCopyWith<$Res> get uiSettings;

}
/// @nodoc
class _$MediaInputCopyWithImpl<$Res>
    implements $MediaInputCopyWith<$Res> {
  _$MediaInputCopyWithImpl(this._self, this._then);

  final MediaInput _self;
  final $Res Function(MediaInput) _then;

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? importSettings = null,Object? maxCount = freezed,Object? minCount = null,Object? initialValues = freezed,Object? getCustomError = freezed,Object? onValueChanged = freezed,Object? submitFormOnSelect = null,Object? uploadPath = freezed,Object? uiSettings = null,}) {
  return _then(MediaInput(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,importSettings: null == importSettings ? _self.importSettings : importSettings // ignore: cast_nullable_to_non_nullable
as MediaImportSettings,maxCount: freezed == maxCount ? _self.maxCount : maxCount // ignore: cast_nullable_to_non_nullable
as int?,minCount: null == minCount ? _self.minCount : minCount // ignore: cast_nullable_to_non_nullable
as int,initialValues: freezed == initialValues ? _self._initialValues : initialValues // ignore: cast_nullable_to_non_nullable
as List<Media>?,getCustomError: freezed == getCustomError ? _self.getCustomError : getCustomError // ignore: cast_nullable_to_non_nullable
as GetCustomErrorForListDef<Media>?,onValueChanged: freezed == onValueChanged ? _self.onValueChanged : onValueChanged // ignore: cast_nullable_to_non_nullable
as void Function(List<Media>? value)?,submitFormOnSelect: null == submitFormOnSelect ? _self.submitFormOnSelect : submitFormOnSelect // ignore: cast_nullable_to_non_nullable
as bool,uploadPath: freezed == uploadPath ? _self.uploadPath : uploadPath // ignore: cast_nullable_to_non_nullable
as String?,uiSettings: null == uiSettings ? _self.uiSettings : uiSettings // ignore: cast_nullable_to_non_nullable
as MediaInputUiSettings,
  ));
}

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MediaImportSettingsCopyWith<$Res> get importSettings {
  
  return $MediaImportSettingsCopyWith<$Res>(_self.importSettings, (value) {
    return _then(_self.copyWith(importSettings: value));
  });
}/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MediaInputUiSettingsCopyWith<$Res> get uiSettings {
  
  return $MediaInputUiSettingsCopyWith<$Res>(_self.uiSettings, (value) {
    return _then(_self.copyWith(uiSettings: value));
  });
}
}

/// @nodoc
@JsonSerializable()

class NumInput extends WoFormInput {
  const NumInput({required this.id, this.initialValue, this.isRequired = false, this.maxBound, this.minBound = 0, @notSerializable this.getCustomError, @notSerializable this.onValueChanged, this.uiSettings = const NumInputUiSettings(), final  String? $type}): assert(maxBound == null || minBound <= maxBound, 'maxBound must be higher or equal to minBound'),$type = $type ?? 'num',super._();
  factory NumInput.fromJson(Map<String, dynamic> json) => _$NumInputFromJson(json);

@override final  String id;
 final  num? initialValue;
@JsonKey() final  bool isRequired;
 final  int? maxBound;
@JsonKey() final  int minBound;
@override@notSerializable final  GetCustomErrorDef<num>? getCustomError;
/// An optionnal callback when the value changed
@notSerializable final  void Function(num? value)? onValueChanged;
@override@JsonKey() final  NumInputUiSettings uiSettings;

@JsonKey(name: 'runtimeType')
final String $type;


/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NumInputCopyWith<NumInput> get copyWith => _$NumInputCopyWithImpl<NumInput>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NumInputToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NumInput&&(identical(other.id, id) || other.id == id)&&(identical(other.initialValue, initialValue) || other.initialValue == initialValue)&&(identical(other.isRequired, isRequired) || other.isRequired == isRequired)&&(identical(other.maxBound, maxBound) || other.maxBound == maxBound)&&(identical(other.minBound, minBound) || other.minBound == minBound)&&(identical(other.getCustomError, getCustomError) || other.getCustomError == getCustomError)&&(identical(other.onValueChanged, onValueChanged) || other.onValueChanged == onValueChanged)&&(identical(other.uiSettings, uiSettings) || other.uiSettings == uiSettings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,initialValue,isRequired,maxBound,minBound,getCustomError,onValueChanged,uiSettings);

@override
String toString() {
  return 'WoFormInput.num(id: $id, initialValue: $initialValue, isRequired: $isRequired, maxBound: $maxBound, minBound: $minBound, getCustomError: $getCustomError, onValueChanged: $onValueChanged, uiSettings: $uiSettings)';
}


}

/// @nodoc
abstract mixin class $NumInputCopyWith<$Res> implements $WoFormInputCopyWith<$Res> {
  factory $NumInputCopyWith(NumInput value, $Res Function(NumInput) _then) = _$NumInputCopyWithImpl;
@override @useResult
$Res call({
 String id, num? initialValue, bool isRequired, int? maxBound, int minBound,@notSerializable GetCustomErrorDef<num>? getCustomError,@notSerializable void Function(num? value)? onValueChanged, NumInputUiSettings uiSettings
});


$NumInputUiSettingsCopyWith<$Res> get uiSettings;

}
/// @nodoc
class _$NumInputCopyWithImpl<$Res>
    implements $NumInputCopyWith<$Res> {
  _$NumInputCopyWithImpl(this._self, this._then);

  final NumInput _self;
  final $Res Function(NumInput) _then;

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? initialValue = freezed,Object? isRequired = null,Object? maxBound = freezed,Object? minBound = null,Object? getCustomError = freezed,Object? onValueChanged = freezed,Object? uiSettings = null,}) {
  return _then(NumInput(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,initialValue: freezed == initialValue ? _self.initialValue : initialValue // ignore: cast_nullable_to_non_nullable
as num?,isRequired: null == isRequired ? _self.isRequired : isRequired // ignore: cast_nullable_to_non_nullable
as bool,maxBound: freezed == maxBound ? _self.maxBound : maxBound // ignore: cast_nullable_to_non_nullable
as int?,minBound: null == minBound ? _self.minBound : minBound // ignore: cast_nullable_to_non_nullable
as int,getCustomError: freezed == getCustomError ? _self.getCustomError : getCustomError // ignore: cast_nullable_to_non_nullable
as GetCustomErrorDef<num>?,onValueChanged: freezed == onValueChanged ? _self.onValueChanged : onValueChanged // ignore: cast_nullable_to_non_nullable
as void Function(num? value)?,uiSettings: null == uiSettings ? _self.uiSettings : uiSettings // ignore: cast_nullable_to_non_nullable
as NumInputUiSettings,
  ));
}

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NumInputUiSettingsCopyWith<$Res> get uiSettings {
  
  return $NumInputUiSettingsCopyWith<$Res>(_self.uiSettings, (value) {
    return _then(_self.copyWith(uiSettings: value));
  });
}
}

/// @nodoc
@JsonSerializable()

class SelectStringInput extends WoFormInput {
  const SelectStringInput({required this.id, required this.maxCount, this.minCount = 0, final  List<String>? initialValues, final  List<String> availibleValues = const [], final  List<String>? idsOfAvailibleValues, @notSerializable this.getCustomError, @notSerializable this.onValueChanged, this.submitFormOnSelect = false, @JsonKey(toJson: _SelectInputUiSettingsX.staticToJsonString) this.uiSettings = const SelectInputUiSettings<String>(), @JsonKey(toJson: QuizSettings.staticToJson) this.quizSettings, final  String? $type}): assert(maxCount == null || minCount <= maxCount, 'maxCount must be higher or equal to minCount'),_initialValues = initialValues,_availibleValues = availibleValues,_idsOfAvailibleValues = idsOfAvailibleValues,$type = $type ?? 'selectString',super._();
  factory SelectStringInput.fromJson(Map<String, dynamic> json) => _$SelectStringInputFromJson(json);

@override final  String id;
 final  int? maxCount;
@JsonKey() final  int minCount;
 final  List<String>? _initialValues;
 List<String>? get initialValues {
  final value = _initialValues;
  if (value == null) return null;
  if (_initialValues is EqualUnmodifiableListView) return _initialValues;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  List<String> _availibleValues;
@JsonKey() List<String> get availibleValues {
  if (_availibleValues is EqualUnmodifiableListView) return _availibleValues;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_availibleValues);
}

// idsOfAvailibleValues allows to set an identifier to each value.
// This way, we keep the advantage of a list : the order
// and we gain the advantage of a map : the identifiers
// while staying jsonifiable.
// If set, the object stored at the path of this input in WoFormValuesCubit
// will be the id of the selected value.
 final  List<String>? _idsOfAvailibleValues;
// idsOfAvailibleValues allows to set an identifier to each value.
// This way, we keep the advantage of a list : the order
// and we gain the advantage of a map : the identifiers
// while staying jsonifiable.
// If set, the object stored at the path of this input in WoFormValuesCubit
// will be the id of the selected value.
 List<String>? get idsOfAvailibleValues {
  final value = _idsOfAvailibleValues;
  if (value == null) return null;
  if (_idsOfAvailibleValues is EqualUnmodifiableListView) return _idsOfAvailibleValues;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override@notSerializable final  GetCustomErrorForListDef<String>? getCustomError;
/// An optionnal callback when the value changed
@notSerializable final  void Function(List<String>? value)? onValueChanged;
/// Only applies if maxCount is 1
@JsonKey() final  bool submitFormOnSelect;
@override@JsonKey(toJson: _SelectInputUiSettingsX.staticToJsonString) final  SelectInputUiSettings<String> uiSettings;
// The correct answer is the index of availibleValues
@JsonKey(toJson: QuizSettings.staticToJson) final  QuizSettings? quizSettings;

@JsonKey(name: 'runtimeType')
final String $type;


/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectStringInputCopyWith<SelectStringInput> get copyWith => _$SelectStringInputCopyWithImpl<SelectStringInput>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectStringInputToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectStringInput&&(identical(other.id, id) || other.id == id)&&(identical(other.maxCount, maxCount) || other.maxCount == maxCount)&&(identical(other.minCount, minCount) || other.minCount == minCount)&&const DeepCollectionEquality().equals(other._initialValues, _initialValues)&&const DeepCollectionEquality().equals(other._availibleValues, _availibleValues)&&const DeepCollectionEquality().equals(other._idsOfAvailibleValues, _idsOfAvailibleValues)&&(identical(other.getCustomError, getCustomError) || other.getCustomError == getCustomError)&&(identical(other.onValueChanged, onValueChanged) || other.onValueChanged == onValueChanged)&&(identical(other.submitFormOnSelect, submitFormOnSelect) || other.submitFormOnSelect == submitFormOnSelect)&&(identical(other.uiSettings, uiSettings) || other.uiSettings == uiSettings)&&(identical(other.quizSettings, quizSettings) || other.quizSettings == quizSettings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,maxCount,minCount,const DeepCollectionEquality().hash(_initialValues),const DeepCollectionEquality().hash(_availibleValues),const DeepCollectionEquality().hash(_idsOfAvailibleValues),getCustomError,onValueChanged,submitFormOnSelect,uiSettings,quizSettings);

@override
String toString() {
  return 'WoFormInput.selectString(id: $id, maxCount: $maxCount, minCount: $minCount, initialValues: $initialValues, availibleValues: $availibleValues, idsOfAvailibleValues: $idsOfAvailibleValues, getCustomError: $getCustomError, onValueChanged: $onValueChanged, submitFormOnSelect: $submitFormOnSelect, uiSettings: $uiSettings, quizSettings: $quizSettings)';
}


}

/// @nodoc
abstract mixin class $SelectStringInputCopyWith<$Res> implements $WoFormInputCopyWith<$Res> {
  factory $SelectStringInputCopyWith(SelectStringInput value, $Res Function(SelectStringInput) _then) = _$SelectStringInputCopyWithImpl;
@override @useResult
$Res call({
 String id, int? maxCount, int minCount, List<String>? initialValues, List<String> availibleValues, List<String>? idsOfAvailibleValues,@notSerializable GetCustomErrorForListDef<String>? getCustomError,@notSerializable void Function(List<String>? value)? onValueChanged, bool submitFormOnSelect,@JsonKey(toJson: _SelectInputUiSettingsX.staticToJsonString) SelectInputUiSettings<String> uiSettings,@JsonKey(toJson: QuizSettings.staticToJson) QuizSettings? quizSettings
});


$SelectInputUiSettingsCopyWith<String, $Res> get uiSettings;$QuizSettingsCopyWith<$Res>? get quizSettings;

}
/// @nodoc
class _$SelectStringInputCopyWithImpl<$Res>
    implements $SelectStringInputCopyWith<$Res> {
  _$SelectStringInputCopyWithImpl(this._self, this._then);

  final SelectStringInput _self;
  final $Res Function(SelectStringInput) _then;

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? maxCount = freezed,Object? minCount = null,Object? initialValues = freezed,Object? availibleValues = null,Object? idsOfAvailibleValues = freezed,Object? getCustomError = freezed,Object? onValueChanged = freezed,Object? submitFormOnSelect = null,Object? uiSettings = null,Object? quizSettings = freezed,}) {
  return _then(SelectStringInput(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,maxCount: freezed == maxCount ? _self.maxCount : maxCount // ignore: cast_nullable_to_non_nullable
as int?,minCount: null == minCount ? _self.minCount : minCount // ignore: cast_nullable_to_non_nullable
as int,initialValues: freezed == initialValues ? _self._initialValues : initialValues // ignore: cast_nullable_to_non_nullable
as List<String>?,availibleValues: null == availibleValues ? _self._availibleValues : availibleValues // ignore: cast_nullable_to_non_nullable
as List<String>,idsOfAvailibleValues: freezed == idsOfAvailibleValues ? _self._idsOfAvailibleValues : idsOfAvailibleValues // ignore: cast_nullable_to_non_nullable
as List<String>?,getCustomError: freezed == getCustomError ? _self.getCustomError : getCustomError // ignore: cast_nullable_to_non_nullable
as GetCustomErrorForListDef<String>?,onValueChanged: freezed == onValueChanged ? _self.onValueChanged : onValueChanged // ignore: cast_nullable_to_non_nullable
as void Function(List<String>? value)?,submitFormOnSelect: null == submitFormOnSelect ? _self.submitFormOnSelect : submitFormOnSelect // ignore: cast_nullable_to_non_nullable
as bool,uiSettings: null == uiSettings ? _self.uiSettings : uiSettings // ignore: cast_nullable_to_non_nullable
as SelectInputUiSettings<String>,quizSettings: freezed == quizSettings ? _self.quizSettings : quizSettings // ignore: cast_nullable_to_non_nullable
as QuizSettings?,
  ));
}

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectInputUiSettingsCopyWith<String, $Res> get uiSettings {
  
  return $SelectInputUiSettingsCopyWith<String, $Res>(_self.uiSettings, (value) {
    return _then(_self.copyWith(uiSettings: value));
  });
}/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$QuizSettingsCopyWith<$Res>? get quizSettings {
    if (_self.quizSettings == null) {
    return null;
  }

  return $QuizSettingsCopyWith<$Res>(_self.quizSettings!, (value) {
    return _then(_self.copyWith(quizSettings: value));
  });
}
}

/// @nodoc
@JsonSerializable()

class StringInput extends WoFormInput {
  const StringInput({required this.id, this.initialValue, this.isRequired = false, this.regexPattern, @JsonKey(toJson: PlaceAutocompleteSettings.staticToJson) this.placeAutocompleteSettings, @notSerializable this.getCustomError, @JsonKey(toJson: StringInputUiSettings.staticToJson) this.uiSettings = const StringInputUiSettings(), final  String? $type}): $type = $type ?? 'string',super._();
  factory StringInput.fromJson(Map<String, dynamic> json) => _$StringInputFromJson(json);

@override final  String id;
 final  String? initialValue;
@JsonKey() final  bool isRequired;
 final  String? regexPattern;
/// If set, the field will be a place autocomplete.
@JsonKey(toJson: PlaceAutocompleteSettings.staticToJson) final  PlaceAutocompleteSettings? placeAutocompleteSettings;
@override@notSerializable final  GetCustomErrorDef<String>? getCustomError;
@override@JsonKey(toJson: StringInputUiSettings.staticToJson) final  StringInputUiSettings uiSettings;

@JsonKey(name: 'runtimeType')
final String $type;


/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$StringInputCopyWith<StringInput> get copyWith => _$StringInputCopyWithImpl<StringInput>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$StringInputToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is StringInput&&(identical(other.id, id) || other.id == id)&&(identical(other.initialValue, initialValue) || other.initialValue == initialValue)&&(identical(other.isRequired, isRequired) || other.isRequired == isRequired)&&(identical(other.regexPattern, regexPattern) || other.regexPattern == regexPattern)&&(identical(other.placeAutocompleteSettings, placeAutocompleteSettings) || other.placeAutocompleteSettings == placeAutocompleteSettings)&&(identical(other.getCustomError, getCustomError) || other.getCustomError == getCustomError)&&(identical(other.uiSettings, uiSettings) || other.uiSettings == uiSettings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,initialValue,isRequired,regexPattern,placeAutocompleteSettings,getCustomError,uiSettings);

@override
String toString() {
  return 'WoFormInput.string(id: $id, initialValue: $initialValue, isRequired: $isRequired, regexPattern: $regexPattern, placeAutocompleteSettings: $placeAutocompleteSettings, getCustomError: $getCustomError, uiSettings: $uiSettings)';
}


}

/// @nodoc
abstract mixin class $StringInputCopyWith<$Res> implements $WoFormInputCopyWith<$Res> {
  factory $StringInputCopyWith(StringInput value, $Res Function(StringInput) _then) = _$StringInputCopyWithImpl;
@override @useResult
$Res call({
 String id, String? initialValue, bool isRequired, String? regexPattern,@JsonKey(toJson: PlaceAutocompleteSettings.staticToJson) PlaceAutocompleteSettings? placeAutocompleteSettings,@notSerializable GetCustomErrorDef<String>? getCustomError,@JsonKey(toJson: StringInputUiSettings.staticToJson) StringInputUiSettings uiSettings
});


$PlaceAutocompleteSettingsCopyWith<$Res>? get placeAutocompleteSettings;$StringInputUiSettingsCopyWith<$Res> get uiSettings;

}
/// @nodoc
class _$StringInputCopyWithImpl<$Res>
    implements $StringInputCopyWith<$Res> {
  _$StringInputCopyWithImpl(this._self, this._then);

  final StringInput _self;
  final $Res Function(StringInput) _then;

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? initialValue = freezed,Object? isRequired = null,Object? regexPattern = freezed,Object? placeAutocompleteSettings = freezed,Object? getCustomError = freezed,Object? uiSettings = null,}) {
  return _then(StringInput(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,initialValue: freezed == initialValue ? _self.initialValue : initialValue // ignore: cast_nullable_to_non_nullable
as String?,isRequired: null == isRequired ? _self.isRequired : isRequired // ignore: cast_nullable_to_non_nullable
as bool,regexPattern: freezed == regexPattern ? _self.regexPattern : regexPattern // ignore: cast_nullable_to_non_nullable
as String?,placeAutocompleteSettings: freezed == placeAutocompleteSettings ? _self.placeAutocompleteSettings : placeAutocompleteSettings // ignore: cast_nullable_to_non_nullable
as PlaceAutocompleteSettings?,getCustomError: freezed == getCustomError ? _self.getCustomError : getCustomError // ignore: cast_nullable_to_non_nullable
as GetCustomErrorDef<String>?,uiSettings: null == uiSettings ? _self.uiSettings : uiSettings // ignore: cast_nullable_to_non_nullable
as StringInputUiSettings,
  ));
}

/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PlaceAutocompleteSettingsCopyWith<$Res>? get placeAutocompleteSettings {
    if (_self.placeAutocompleteSettings == null) {
    return null;
  }

  return $PlaceAutocompleteSettingsCopyWith<$Res>(_self.placeAutocompleteSettings!, (value) {
    return _then(_self.copyWith(placeAutocompleteSettings: value));
  });
}/// Create a copy of WoFormInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$StringInputUiSettingsCopyWith<$Res> get uiSettings {
  
  return $StringInputUiSettingsCopyWith<$Res>(_self.uiSettings, (value) {
    return _then(_self.copyWith(uiSettings: value));
  });
}
}


/// @nodoc
mixin _$SelectInput<T> {

 String get id; int? get maxCount; int get minCount; List<T>? get initialValues; List<T> get availibleValues;/// idsOfAvailibleValues allows to set an identifier to each value.
/// This way, we keep the advantage of a list : the order
/// and we gain the advantage of a map : the identifiers
/// while staying jsonifiable.
/// If set, the object stored at the path of this input in WoFormValuesCubit
/// will be the id of the selected value.
 List<String>? get idsOfAvailibleValues;/// An optionnal callback when the value changed
@notSerializable void Function(List<T>? value)? get onValueChanged;@notSerializable GetCustomErrorForListDef<T>? get getCustomError;/// Only applies if maxCount is 1
 bool get submitFormOnSelect; SelectInputUiSettings<T>? get uiSettings;@JsonKey(toJson: QuizSettings.staticToJson) QuizSettings? get quizSettings;/// The following fields are mostly usefull for hydrataion
///
/// Ex :
/// SelectInput<TimeControl>(
///   toJsonT: (value) => (value as TimeControl?)?.toJson(),
///   fromJsonT: (json) =>
///       TimeControl.fromJson(json as Map<String, dynamic>? ?? {}),
/// ),
@notSerializable dynamic Function(dynamic)? get toJsonT;@notSerializable dynamic Function(dynamic)? get fromJsonT;
/// Create a copy of SelectInput
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectInputCopyWith<T, SelectInput<T>> get copyWith => _$SelectInputCopyWithImpl<T, SelectInput<T>>(this as SelectInput<T>, _$identity);

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectInput<T>&&(identical(other.id, id) || other.id == id)&&(identical(other.maxCount, maxCount) || other.maxCount == maxCount)&&(identical(other.minCount, minCount) || other.minCount == minCount)&&const DeepCollectionEquality().equals(other.initialValues, initialValues)&&const DeepCollectionEquality().equals(other.availibleValues, availibleValues)&&const DeepCollectionEquality().equals(other.idsOfAvailibleValues, idsOfAvailibleValues)&&(identical(other.onValueChanged, onValueChanged) || other.onValueChanged == onValueChanged)&&(identical(other.getCustomError, getCustomError) || other.getCustomError == getCustomError)&&(identical(other.submitFormOnSelect, submitFormOnSelect) || other.submitFormOnSelect == submitFormOnSelect)&&(identical(other.uiSettings, uiSettings) || other.uiSettings == uiSettings)&&(identical(other.quizSettings, quizSettings) || other.quizSettings == quizSettings)&&(identical(other.toJsonT, toJsonT) || other.toJsonT == toJsonT)&&(identical(other.fromJsonT, fromJsonT) || other.fromJsonT == fromJsonT));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,maxCount,minCount,const DeepCollectionEquality().hash(initialValues),const DeepCollectionEquality().hash(availibleValues),const DeepCollectionEquality().hash(idsOfAvailibleValues),onValueChanged,getCustomError,submitFormOnSelect,uiSettings,quizSettings,toJsonT,fromJsonT);

@override
String toString() {
  return 'SelectInput<$T>(id: $id, maxCount: $maxCount, minCount: $minCount, initialValues: $initialValues, availibleValues: $availibleValues, idsOfAvailibleValues: $idsOfAvailibleValues, onValueChanged: $onValueChanged, getCustomError: $getCustomError, submitFormOnSelect: $submitFormOnSelect, uiSettings: $uiSettings, quizSettings: $quizSettings, toJsonT: $toJsonT, fromJsonT: $fromJsonT)';
}


}

/// @nodoc
abstract mixin class $SelectInputCopyWith<T,$Res>  {
  factory $SelectInputCopyWith(SelectInput<T> value, $Res Function(SelectInput<T>) _then) = _$SelectInputCopyWithImpl;
@useResult
$Res call({
 String id, int? maxCount, int minCount, List<T>? initialValues, List<T> availibleValues, List<String>? idsOfAvailibleValues,@notSerializable void Function(List<T>? value)? onValueChanged,@notSerializable GetCustomErrorForListDef<T>? getCustomError, bool submitFormOnSelect, SelectInputUiSettings<T>? uiSettings,@JsonKey(toJson: QuizSettings.staticToJson) QuizSettings? quizSettings,@notSerializable dynamic Function(dynamic)? toJsonT,@notSerializable dynamic Function(dynamic)? fromJsonT
});


$SelectInputUiSettingsCopyWith<T, $Res>? get uiSettings;$QuizSettingsCopyWith<$Res>? get quizSettings;

}
/// @nodoc
class _$SelectInputCopyWithImpl<T,$Res>
    implements $SelectInputCopyWith<T, $Res> {
  _$SelectInputCopyWithImpl(this._self, this._then);

  final SelectInput<T> _self;
  final $Res Function(SelectInput<T>) _then;

/// Create a copy of SelectInput
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? maxCount = freezed,Object? minCount = null,Object? initialValues = freezed,Object? availibleValues = null,Object? idsOfAvailibleValues = freezed,Object? onValueChanged = freezed,Object? getCustomError = freezed,Object? submitFormOnSelect = null,Object? uiSettings = freezed,Object? quizSettings = freezed,Object? toJsonT = freezed,Object? fromJsonT = freezed,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,maxCount: freezed == maxCount ? _self.maxCount : maxCount // ignore: cast_nullable_to_non_nullable
as int?,minCount: null == minCount ? _self.minCount : minCount // ignore: cast_nullable_to_non_nullable
as int,initialValues: freezed == initialValues ? _self.initialValues : initialValues // ignore: cast_nullable_to_non_nullable
as List<T>?,availibleValues: null == availibleValues ? _self.availibleValues : availibleValues // ignore: cast_nullable_to_non_nullable
as List<T>,idsOfAvailibleValues: freezed == idsOfAvailibleValues ? _self.idsOfAvailibleValues : idsOfAvailibleValues // ignore: cast_nullable_to_non_nullable
as List<String>?,onValueChanged: freezed == onValueChanged ? _self.onValueChanged : onValueChanged // ignore: cast_nullable_to_non_nullable
as void Function(List<T>? value)?,getCustomError: freezed == getCustomError ? _self.getCustomError : getCustomError // ignore: cast_nullable_to_non_nullable
as GetCustomErrorForListDef<T>?,submitFormOnSelect: null == submitFormOnSelect ? _self.submitFormOnSelect : submitFormOnSelect // ignore: cast_nullable_to_non_nullable
as bool,uiSettings: freezed == uiSettings ? _self.uiSettings : uiSettings // ignore: cast_nullable_to_non_nullable
as SelectInputUiSettings<T>?,quizSettings: freezed == quizSettings ? _self.quizSettings : quizSettings // ignore: cast_nullable_to_non_nullable
as QuizSettings?,toJsonT: freezed == toJsonT ? _self.toJsonT : toJsonT // ignore: cast_nullable_to_non_nullable
as dynamic Function(dynamic)?,fromJsonT: freezed == fromJsonT ? _self.fromJsonT : fromJsonT // ignore: cast_nullable_to_non_nullable
as dynamic Function(dynamic)?,
  ));
}
/// Create a copy of SelectInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectInputUiSettingsCopyWith<T, $Res>? get uiSettings {
    if (_self.uiSettings == null) {
    return null;
  }

  return $SelectInputUiSettingsCopyWith<T, $Res>(_self.uiSettings!, (value) {
    return _then(_self.copyWith(uiSettings: value));
  });
}/// Create a copy of SelectInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$QuizSettingsCopyWith<$Res>? get quizSettings {
    if (_self.quizSettings == null) {
    return null;
  }

  return $QuizSettingsCopyWith<$Res>(_self.quizSettings!, (value) {
    return _then(_self.copyWith(quizSettings: value));
  });
}
}



/// @nodoc
@JsonSerializable(genericArgumentFactories: true)

class _SelectInput<T> extends SelectInput<T> {
  const _SelectInput({required this.id, required this.maxCount, this.minCount = 0, final  List<T>? initialValues, final  List<T> availibleValues = const [], final  List<String>? idsOfAvailibleValues, @notSerializable this.onValueChanged, @notSerializable this.getCustomError, this.submitFormOnSelect = false, this.uiSettings, @JsonKey(toJson: QuizSettings.staticToJson) this.quizSettings, @notSerializable this.toJsonT, @notSerializable this.fromJsonT}): _initialValues = initialValues,_availibleValues = availibleValues,_idsOfAvailibleValues = idsOfAvailibleValues,super._();
  factory _SelectInput.fromJson(Map<String, dynamic> json,T Function(Object?) fromJsonT) => _$SelectInputFromJson(json,fromJsonT);

@override final  String id;
@override final  int? maxCount;
@override@JsonKey() final  int minCount;
 final  List<T>? _initialValues;
@override List<T>? get initialValues {
  final value = _initialValues;
  if (value == null) return null;
  if (_initialValues is EqualUnmodifiableListView) return _initialValues;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  List<T> _availibleValues;
@override@JsonKey() List<T> get availibleValues {
  if (_availibleValues is EqualUnmodifiableListView) return _availibleValues;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_availibleValues);
}

/// idsOfAvailibleValues allows to set an identifier to each value.
/// This way, we keep the advantage of a list : the order
/// and we gain the advantage of a map : the identifiers
/// while staying jsonifiable.
/// If set, the object stored at the path of this input in WoFormValuesCubit
/// will be the id of the selected value.
 final  List<String>? _idsOfAvailibleValues;
/// idsOfAvailibleValues allows to set an identifier to each value.
/// This way, we keep the advantage of a list : the order
/// and we gain the advantage of a map : the identifiers
/// while staying jsonifiable.
/// If set, the object stored at the path of this input in WoFormValuesCubit
/// will be the id of the selected value.
@override List<String>? get idsOfAvailibleValues {
  final value = _idsOfAvailibleValues;
  if (value == null) return null;
  if (_idsOfAvailibleValues is EqualUnmodifiableListView) return _idsOfAvailibleValues;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// An optionnal callback when the value changed
@override@notSerializable final  void Function(List<T>? value)? onValueChanged;
@override@notSerializable final  GetCustomErrorForListDef<T>? getCustomError;
/// Only applies if maxCount is 1
@override@JsonKey() final  bool submitFormOnSelect;
@override final  SelectInputUiSettings<T>? uiSettings;
@override@JsonKey(toJson: QuizSettings.staticToJson) final  QuizSettings? quizSettings;
/// The following fields are mostly usefull for hydrataion
///
/// Ex :
/// SelectInput<TimeControl>(
///   toJsonT: (value) => (value as TimeControl?)?.toJson(),
///   fromJsonT: (json) =>
///       TimeControl.fromJson(json as Map<String, dynamic>? ?? {}),
/// ),
@override@notSerializable final  dynamic Function(dynamic)? toJsonT;
@override@notSerializable final  dynamic Function(dynamic)? fromJsonT;

/// Create a copy of SelectInput
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectInputCopyWith<T, _SelectInput<T>> get copyWith => __$SelectInputCopyWithImpl<T, _SelectInput<T>>(this, _$identity);

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectInput<T>&&(identical(other.id, id) || other.id == id)&&(identical(other.maxCount, maxCount) || other.maxCount == maxCount)&&(identical(other.minCount, minCount) || other.minCount == minCount)&&const DeepCollectionEquality().equals(other._initialValues, _initialValues)&&const DeepCollectionEquality().equals(other._availibleValues, _availibleValues)&&const DeepCollectionEquality().equals(other._idsOfAvailibleValues, _idsOfAvailibleValues)&&(identical(other.onValueChanged, onValueChanged) || other.onValueChanged == onValueChanged)&&(identical(other.getCustomError, getCustomError) || other.getCustomError == getCustomError)&&(identical(other.submitFormOnSelect, submitFormOnSelect) || other.submitFormOnSelect == submitFormOnSelect)&&(identical(other.uiSettings, uiSettings) || other.uiSettings == uiSettings)&&(identical(other.quizSettings, quizSettings) || other.quizSettings == quizSettings)&&(identical(other.toJsonT, toJsonT) || other.toJsonT == toJsonT)&&(identical(other.fromJsonT, fromJsonT) || other.fromJsonT == fromJsonT));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,maxCount,minCount,const DeepCollectionEquality().hash(_initialValues),const DeepCollectionEquality().hash(_availibleValues),const DeepCollectionEquality().hash(_idsOfAvailibleValues),onValueChanged,getCustomError,submitFormOnSelect,uiSettings,quizSettings,toJsonT,fromJsonT);

@override
String toString() {
  return 'SelectInput<$T>(id: $id, maxCount: $maxCount, minCount: $minCount, initialValues: $initialValues, availibleValues: $availibleValues, idsOfAvailibleValues: $idsOfAvailibleValues, onValueChanged: $onValueChanged, getCustomError: $getCustomError, submitFormOnSelect: $submitFormOnSelect, uiSettings: $uiSettings, quizSettings: $quizSettings, toJsonT: $toJsonT, fromJsonT: $fromJsonT)';
}


}

/// @nodoc
abstract mixin class _$SelectInputCopyWith<T,$Res> implements $SelectInputCopyWith<T, $Res> {
  factory _$SelectInputCopyWith(_SelectInput<T> value, $Res Function(_SelectInput<T>) _then) = __$SelectInputCopyWithImpl;
@override @useResult
$Res call({
 String id, int? maxCount, int minCount, List<T>? initialValues, List<T> availibleValues, List<String>? idsOfAvailibleValues,@notSerializable void Function(List<T>? value)? onValueChanged,@notSerializable GetCustomErrorForListDef<T>? getCustomError, bool submitFormOnSelect, SelectInputUiSettings<T>? uiSettings,@JsonKey(toJson: QuizSettings.staticToJson) QuizSettings? quizSettings,@notSerializable dynamic Function(dynamic)? toJsonT,@notSerializable dynamic Function(dynamic)? fromJsonT
});


@override $SelectInputUiSettingsCopyWith<T, $Res>? get uiSettings;@override $QuizSettingsCopyWith<$Res>? get quizSettings;

}
/// @nodoc
class __$SelectInputCopyWithImpl<T,$Res>
    implements _$SelectInputCopyWith<T, $Res> {
  __$SelectInputCopyWithImpl(this._self, this._then);

  final _SelectInput<T> _self;
  final $Res Function(_SelectInput<T>) _then;

/// Create a copy of SelectInput
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? maxCount = freezed,Object? minCount = null,Object? initialValues = freezed,Object? availibleValues = null,Object? idsOfAvailibleValues = freezed,Object? onValueChanged = freezed,Object? getCustomError = freezed,Object? submitFormOnSelect = null,Object? uiSettings = freezed,Object? quizSettings = freezed,Object? toJsonT = freezed,Object? fromJsonT = freezed,}) {
  return _then(_SelectInput<T>(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,maxCount: freezed == maxCount ? _self.maxCount : maxCount // ignore: cast_nullable_to_non_nullable
as int?,minCount: null == minCount ? _self.minCount : minCount // ignore: cast_nullable_to_non_nullable
as int,initialValues: freezed == initialValues ? _self._initialValues : initialValues // ignore: cast_nullable_to_non_nullable
as List<T>?,availibleValues: null == availibleValues ? _self._availibleValues : availibleValues // ignore: cast_nullable_to_non_nullable
as List<T>,idsOfAvailibleValues: freezed == idsOfAvailibleValues ? _self._idsOfAvailibleValues : idsOfAvailibleValues // ignore: cast_nullable_to_non_nullable
as List<String>?,onValueChanged: freezed == onValueChanged ? _self.onValueChanged : onValueChanged // ignore: cast_nullable_to_non_nullable
as void Function(List<T>? value)?,getCustomError: freezed == getCustomError ? _self.getCustomError : getCustomError // ignore: cast_nullable_to_non_nullable
as GetCustomErrorForListDef<T>?,submitFormOnSelect: null == submitFormOnSelect ? _self.submitFormOnSelect : submitFormOnSelect // ignore: cast_nullable_to_non_nullable
as bool,uiSettings: freezed == uiSettings ? _self.uiSettings : uiSettings // ignore: cast_nullable_to_non_nullable
as SelectInputUiSettings<T>?,quizSettings: freezed == quizSettings ? _self.quizSettings : quizSettings // ignore: cast_nullable_to_non_nullable
as QuizSettings?,toJsonT: freezed == toJsonT ? _self.toJsonT : toJsonT // ignore: cast_nullable_to_non_nullable
as dynamic Function(dynamic)?,fromJsonT: freezed == fromJsonT ? _self.fromJsonT : fromJsonT // ignore: cast_nullable_to_non_nullable
as dynamic Function(dynamic)?,
  ));
}

/// Create a copy of SelectInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectInputUiSettingsCopyWith<T, $Res>? get uiSettings {
    if (_self.uiSettings == null) {
    return null;
  }

  return $SelectInputUiSettingsCopyWith<T, $Res>(_self.uiSettings!, (value) {
    return _then(_self.copyWith(uiSettings: value));
  });
}/// Create a copy of SelectInput
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$QuizSettingsCopyWith<$Res>? get quizSettings {
    if (_self.quizSettings == null) {
    return null;
  }

  return $QuizSettingsCopyWith<$Res>(_self.quizSettings!, (value) {
    return _then(_self.copyWith(quizSettings: value));
  });
}
}

// dart format on
