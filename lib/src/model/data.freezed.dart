// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$WoFormHeaderData {

 String? get labelText; String? get helperText;
/// Create a copy of WoFormHeaderData
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WoFormHeaderDataCopyWith<WoFormHeaderData> get copyWith => _$WoFormHeaderDataCopyWithImpl<WoFormHeaderData>(this as WoFormHeaderData, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WoFormHeaderData&&(identical(other.labelText, labelText) || other.labelText == labelText)&&(identical(other.helperText, helperText) || other.helperText == helperText));
}


@override
int get hashCode => Object.hash(runtimeType,labelText,helperText);

@override
String toString() {
  return 'WoFormHeaderData(labelText: $labelText, helperText: $helperText)';
}


}

/// @nodoc
abstract mixin class $WoFormHeaderDataCopyWith<$Res>  {
  factory $WoFormHeaderDataCopyWith(WoFormHeaderData value, $Res Function(WoFormHeaderData) _then) = _$WoFormHeaderDataCopyWithImpl;
@useResult
$Res call({
 String? labelText, String? helperText
});




}
/// @nodoc
class _$WoFormHeaderDataCopyWithImpl<$Res>
    implements $WoFormHeaderDataCopyWith<$Res> {
  _$WoFormHeaderDataCopyWithImpl(this._self, this._then);

  final WoFormHeaderData _self;
  final $Res Function(WoFormHeaderData) _then;

/// Create a copy of WoFormHeaderData
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? labelText = freezed,Object? helperText = freezed,}) {
  return _then(_self.copyWith(
labelText: freezed == labelText ? _self.labelText : labelText // ignore: cast_nullable_to_non_nullable
as String?,helperText: freezed == helperText ? _self.helperText : helperText // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc


class _WoFormHeaderData implements WoFormHeaderData {
  const _WoFormHeaderData({this.labelText, this.helperText});
  

@override final  String? labelText;
@override final  String? helperText;

/// Create a copy of WoFormHeaderData
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WoFormHeaderDataCopyWith<_WoFormHeaderData> get copyWith => __$WoFormHeaderDataCopyWithImpl<_WoFormHeaderData>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WoFormHeaderData&&(identical(other.labelText, labelText) || other.labelText == labelText)&&(identical(other.helperText, helperText) || other.helperText == helperText));
}


@override
int get hashCode => Object.hash(runtimeType,labelText,helperText);

@override
String toString() {
  return 'WoFormHeaderData(labelText: $labelText, helperText: $helperText)';
}


}

/// @nodoc
abstract mixin class _$WoFormHeaderDataCopyWith<$Res> implements $WoFormHeaderDataCopyWith<$Res> {
  factory _$WoFormHeaderDataCopyWith(_WoFormHeaderData value, $Res Function(_WoFormHeaderData) _then) = __$WoFormHeaderDataCopyWithImpl;
@override @useResult
$Res call({
 String? labelText, String? helperText
});




}
/// @nodoc
class __$WoFormHeaderDataCopyWithImpl<$Res>
    implements _$WoFormHeaderDataCopyWith<$Res> {
  __$WoFormHeaderDataCopyWithImpl(this._self, this._then);

  final _WoFormHeaderData _self;
  final $Res Function(_WoFormHeaderData) _then;

/// Create a copy of WoFormHeaderData
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? labelText = freezed,Object? helperText = freezed,}) {
  return _then(_WoFormHeaderData(
labelText: freezed == labelText ? _self.labelText : labelText // ignore: cast_nullable_to_non_nullable
as String?,helperText: freezed == helperText ? _self.helperText : helperText // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

/// @nodoc
mixin _$WoFormInputHeaderData {

 String? get labelText; int? get labelMaxLines; String? get helperText; String? get errorText; Widget? get trailing; VoidCallback? get onTap; bool get shrinkWrap;
/// Create a copy of WoFormInputHeaderData
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WoFormInputHeaderDataCopyWith<WoFormInputHeaderData> get copyWith => _$WoFormInputHeaderDataCopyWithImpl<WoFormInputHeaderData>(this as WoFormInputHeaderData, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WoFormInputHeaderData&&(identical(other.labelText, labelText) || other.labelText == labelText)&&(identical(other.labelMaxLines, labelMaxLines) || other.labelMaxLines == labelMaxLines)&&(identical(other.helperText, helperText) || other.helperText == helperText)&&(identical(other.errorText, errorText) || other.errorText == errorText)&&(identical(other.trailing, trailing) || other.trailing == trailing)&&(identical(other.onTap, onTap) || other.onTap == onTap)&&(identical(other.shrinkWrap, shrinkWrap) || other.shrinkWrap == shrinkWrap));
}


@override
int get hashCode => Object.hash(runtimeType,labelText,labelMaxLines,helperText,errorText,trailing,onTap,shrinkWrap);

@override
String toString() {
  return 'WoFormInputHeaderData(labelText: $labelText, labelMaxLines: $labelMaxLines, helperText: $helperText, errorText: $errorText, trailing: $trailing, onTap: $onTap, shrinkWrap: $shrinkWrap)';
}


}

/// @nodoc
abstract mixin class $WoFormInputHeaderDataCopyWith<$Res>  {
  factory $WoFormInputHeaderDataCopyWith(WoFormInputHeaderData value, $Res Function(WoFormInputHeaderData) _then) = _$WoFormInputHeaderDataCopyWithImpl;
@useResult
$Res call({
 String? labelText, int? labelMaxLines, String? helperText, String? errorText, Widget? trailing, VoidCallback? onTap, bool shrinkWrap
});




}
/// @nodoc
class _$WoFormInputHeaderDataCopyWithImpl<$Res>
    implements $WoFormInputHeaderDataCopyWith<$Res> {
  _$WoFormInputHeaderDataCopyWithImpl(this._self, this._then);

  final WoFormInputHeaderData _self;
  final $Res Function(WoFormInputHeaderData) _then;

/// Create a copy of WoFormInputHeaderData
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? labelText = freezed,Object? labelMaxLines = freezed,Object? helperText = freezed,Object? errorText = freezed,Object? trailing = freezed,Object? onTap = freezed,Object? shrinkWrap = null,}) {
  return _then(_self.copyWith(
labelText: freezed == labelText ? _self.labelText : labelText // ignore: cast_nullable_to_non_nullable
as String?,labelMaxLines: freezed == labelMaxLines ? _self.labelMaxLines : labelMaxLines // ignore: cast_nullable_to_non_nullable
as int?,helperText: freezed == helperText ? _self.helperText : helperText // ignore: cast_nullable_to_non_nullable
as String?,errorText: freezed == errorText ? _self.errorText : errorText // ignore: cast_nullable_to_non_nullable
as String?,trailing: freezed == trailing ? _self.trailing : trailing // ignore: cast_nullable_to_non_nullable
as Widget?,onTap: freezed == onTap ? _self.onTap : onTap // ignore: cast_nullable_to_non_nullable
as VoidCallback?,shrinkWrap: null == shrinkWrap ? _self.shrinkWrap : shrinkWrap // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc


class _WoFormInputHeaderData implements WoFormInputHeaderData {
  const _WoFormInputHeaderData({this.labelText, this.labelMaxLines, this.helperText, this.errorText, this.trailing, this.onTap, this.shrinkWrap = true});
  

@override final  String? labelText;
@override final  int? labelMaxLines;
@override final  String? helperText;
@override final  String? errorText;
@override final  Widget? trailing;
@override final  VoidCallback? onTap;
@override@JsonKey() final  bool shrinkWrap;

/// Create a copy of WoFormInputHeaderData
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WoFormInputHeaderDataCopyWith<_WoFormInputHeaderData> get copyWith => __$WoFormInputHeaderDataCopyWithImpl<_WoFormInputHeaderData>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WoFormInputHeaderData&&(identical(other.labelText, labelText) || other.labelText == labelText)&&(identical(other.labelMaxLines, labelMaxLines) || other.labelMaxLines == labelMaxLines)&&(identical(other.helperText, helperText) || other.helperText == helperText)&&(identical(other.errorText, errorText) || other.errorText == errorText)&&(identical(other.trailing, trailing) || other.trailing == trailing)&&(identical(other.onTap, onTap) || other.onTap == onTap)&&(identical(other.shrinkWrap, shrinkWrap) || other.shrinkWrap == shrinkWrap));
}


@override
int get hashCode => Object.hash(runtimeType,labelText,labelMaxLines,helperText,errorText,trailing,onTap,shrinkWrap);

@override
String toString() {
  return 'WoFormInputHeaderData(labelText: $labelText, labelMaxLines: $labelMaxLines, helperText: $helperText, errorText: $errorText, trailing: $trailing, onTap: $onTap, shrinkWrap: $shrinkWrap)';
}


}

/// @nodoc
abstract mixin class _$WoFormInputHeaderDataCopyWith<$Res> implements $WoFormInputHeaderDataCopyWith<$Res> {
  factory _$WoFormInputHeaderDataCopyWith(_WoFormInputHeaderData value, $Res Function(_WoFormInputHeaderData) _then) = __$WoFormInputHeaderDataCopyWithImpl;
@override @useResult
$Res call({
 String? labelText, int? labelMaxLines, String? helperText, String? errorText, Widget? trailing, VoidCallback? onTap, bool shrinkWrap
});




}
/// @nodoc
class __$WoFormInputHeaderDataCopyWithImpl<$Res>
    implements _$WoFormInputHeaderDataCopyWith<$Res> {
  __$WoFormInputHeaderDataCopyWithImpl(this._self, this._then);

  final _WoFormInputHeaderData _self;
  final $Res Function(_WoFormInputHeaderData) _then;

/// Create a copy of WoFormInputHeaderData
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? labelText = freezed,Object? labelMaxLines = freezed,Object? helperText = freezed,Object? errorText = freezed,Object? trailing = freezed,Object? onTap = freezed,Object? shrinkWrap = null,}) {
  return _then(_WoFormInputHeaderData(
labelText: freezed == labelText ? _self.labelText : labelText // ignore: cast_nullable_to_non_nullable
as String?,labelMaxLines: freezed == labelMaxLines ? _self.labelMaxLines : labelMaxLines // ignore: cast_nullable_to_non_nullable
as int?,helperText: freezed == helperText ? _self.helperText : helperText // ignore: cast_nullable_to_non_nullable
as String?,errorText: freezed == errorText ? _self.errorText : errorText // ignore: cast_nullable_to_non_nullable
as String?,trailing: freezed == trailing ? _self.trailing : trailing // ignore: cast_nullable_to_non_nullable
as Widget?,onTap: freezed == onTap ? _self.onTap : onTap // ignore: cast_nullable_to_non_nullable
as VoidCallback?,shrinkWrap: null == shrinkWrap ? _self.shrinkWrap : shrinkWrap // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

/// @nodoc
mixin _$WoFieldData<I,T> {

 String get path; I get input; T? get value;/// Null means locked field
 void Function(T? value, {UpdateStatus updateStatus})? get onValueChanged; String? get errorText; Widget? get errorWidget;
/// Create a copy of WoFieldData
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WoFieldDataCopyWith<I, T, WoFieldData<I, T>> get copyWith => _$WoFieldDataCopyWithImpl<I, T, WoFieldData<I, T>>(this as WoFieldData<I, T>, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WoFieldData<I, T>&&(identical(other.path, path) || other.path == path)&&const DeepCollectionEquality().equals(other.input, input)&&const DeepCollectionEquality().equals(other.value, value)&&(identical(other.onValueChanged, onValueChanged) || other.onValueChanged == onValueChanged)&&(identical(other.errorText, errorText) || other.errorText == errorText)&&(identical(other.errorWidget, errorWidget) || other.errorWidget == errorWidget));
}


@override
int get hashCode => Object.hash(runtimeType,path,const DeepCollectionEquality().hash(input),const DeepCollectionEquality().hash(value),onValueChanged,errorText,errorWidget);

@override
String toString() {
  return 'WoFieldData<$I, $T>(path: $path, input: $input, value: $value, onValueChanged: $onValueChanged, errorText: $errorText, errorWidget: $errorWidget)';
}


}

/// @nodoc
abstract mixin class $WoFieldDataCopyWith<I,T,$Res>  {
  factory $WoFieldDataCopyWith(WoFieldData<I, T> value, $Res Function(WoFieldData<I, T>) _then) = _$WoFieldDataCopyWithImpl;
@useResult
$Res call({
 String path, I input, T? value, void Function(T? value, {UpdateStatus updateStatus})? onValueChanged, String? errorText, Widget? errorWidget
});




}
/// @nodoc
class _$WoFieldDataCopyWithImpl<I,T,$Res>
    implements $WoFieldDataCopyWith<I, T, $Res> {
  _$WoFieldDataCopyWithImpl(this._self, this._then);

  final WoFieldData<I, T> _self;
  final $Res Function(WoFieldData<I, T>) _then;

/// Create a copy of WoFieldData
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? path = null,Object? input = freezed,Object? value = freezed,Object? onValueChanged = freezed,Object? errorText = freezed,Object? errorWidget = freezed,}) {
  return _then(_self.copyWith(
path: null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,input: freezed == input ? _self.input : input // ignore: cast_nullable_to_non_nullable
as I,value: freezed == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as T?,onValueChanged: freezed == onValueChanged ? _self.onValueChanged : onValueChanged // ignore: cast_nullable_to_non_nullable
as void Function(T? value, {UpdateStatus updateStatus})?,errorText: freezed == errorText ? _self.errorText : errorText // ignore: cast_nullable_to_non_nullable
as String?,errorWidget: freezed == errorWidget ? _self.errorWidget : errorWidget // ignore: cast_nullable_to_non_nullable
as Widget?,
  ));
}

}



/// @nodoc


class _WoFieldData<I,T> implements WoFieldData<I, T> {
  const _WoFieldData({required this.path, required this.input, required this.value, required this.onValueChanged, this.errorText, this.errorWidget}): assert(errorText == null || errorWidget == null, 'Only one of errorWidget and errorText can be specified.');
  

@override final  String path;
@override final  I input;
@override final  T? value;
/// Null means locked field
@override final  void Function(T? value, {UpdateStatus updateStatus})? onValueChanged;
@override final  String? errorText;
@override final  Widget? errorWidget;

/// Create a copy of WoFieldData
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WoFieldDataCopyWith<I, T, _WoFieldData<I, T>> get copyWith => __$WoFieldDataCopyWithImpl<I, T, _WoFieldData<I, T>>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WoFieldData<I, T>&&(identical(other.path, path) || other.path == path)&&const DeepCollectionEquality().equals(other.input, input)&&const DeepCollectionEquality().equals(other.value, value)&&(identical(other.onValueChanged, onValueChanged) || other.onValueChanged == onValueChanged)&&(identical(other.errorText, errorText) || other.errorText == errorText)&&(identical(other.errorWidget, errorWidget) || other.errorWidget == errorWidget));
}


@override
int get hashCode => Object.hash(runtimeType,path,const DeepCollectionEquality().hash(input),const DeepCollectionEquality().hash(value),onValueChanged,errorText,errorWidget);

@override
String toString() {
  return 'WoFieldData<$I, $T>(path: $path, input: $input, value: $value, onValueChanged: $onValueChanged, errorText: $errorText, errorWidget: $errorWidget)';
}


}

/// @nodoc
abstract mixin class _$WoFieldDataCopyWith<I,T,$Res> implements $WoFieldDataCopyWith<I, T, $Res> {
  factory _$WoFieldDataCopyWith(_WoFieldData<I, T> value, $Res Function(_WoFieldData<I, T>) _then) = __$WoFieldDataCopyWithImpl;
@override @useResult
$Res call({
 String path, I input, T? value, void Function(T? value, {UpdateStatus updateStatus})? onValueChanged, String? errorText, Widget? errorWidget
});




}
/// @nodoc
class __$WoFieldDataCopyWithImpl<I,T,$Res>
    implements _$WoFieldDataCopyWith<I, T, $Res> {
  __$WoFieldDataCopyWithImpl(this._self, this._then);

  final _WoFieldData<I, T> _self;
  final $Res Function(_WoFieldData<I, T>) _then;

/// Create a copy of WoFieldData
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? path = null,Object? input = freezed,Object? value = freezed,Object? onValueChanged = freezed,Object? errorText = freezed,Object? errorWidget = freezed,}) {
  return _then(_WoFieldData<I, T>(
path: null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,input: freezed == input ? _self.input : input // ignore: cast_nullable_to_non_nullable
as I,value: freezed == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as T?,onValueChanged: freezed == onValueChanged ? _self.onValueChanged : onValueChanged // ignore: cast_nullable_to_non_nullable
as void Function(T? value, {UpdateStatus updateStatus})?,errorText: freezed == errorText ? _self.errorText : errorText // ignore: cast_nullable_to_non_nullable
as String?,errorWidget: freezed == errorWidget ? _self.errorWidget : errorWidget // ignore: cast_nullable_to_non_nullable
as Widget?,
  ));
}


}

/// @nodoc
mixin _$SubmitButtonData {

 String? get text;/// Callback invoked when the form (or a part of it) is submitted. This is
/// triggered by the [SubmitButton] or any field configured to submit.
 VoidCallback? get onPressed;/// If not empty, submission validation will be scoped to the node at
/// this path, and its children.
///
/// This is used for validating only a specific section of a larger form.
 String get path; SubmitButtonPosition get position; IconData? get icon;
/// Create a copy of SubmitButtonData
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SubmitButtonDataCopyWith<SubmitButtonData> get copyWith => _$SubmitButtonDataCopyWithImpl<SubmitButtonData>(this as SubmitButtonData, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SubmitButtonData&&(identical(other.text, text) || other.text == text)&&(identical(other.onPressed, onPressed) || other.onPressed == onPressed)&&(identical(other.path, path) || other.path == path)&&(identical(other.position, position) || other.position == position)&&(identical(other.icon, icon) || other.icon == icon));
}


@override
int get hashCode => Object.hash(runtimeType,text,onPressed,path,position,icon);

@override
String toString() {
  return 'SubmitButtonData(text: $text, onPressed: $onPressed, path: $path, position: $position, icon: $icon)';
}


}

/// @nodoc
abstract mixin class $SubmitButtonDataCopyWith<$Res>  {
  factory $SubmitButtonDataCopyWith(SubmitButtonData value, $Res Function(SubmitButtonData) _then) = _$SubmitButtonDataCopyWithImpl;
@useResult
$Res call({
 String? text, VoidCallback? onPressed, String path, SubmitButtonPosition position, IconData? icon
});




}
/// @nodoc
class _$SubmitButtonDataCopyWithImpl<$Res>
    implements $SubmitButtonDataCopyWith<$Res> {
  _$SubmitButtonDataCopyWithImpl(this._self, this._then);

  final SubmitButtonData _self;
  final $Res Function(SubmitButtonData) _then;

/// Create a copy of SubmitButtonData
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? text = freezed,Object? onPressed = freezed,Object? path = null,Object? position = null,Object? icon = freezed,}) {
  return _then(_self.copyWith(
text: freezed == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String?,onPressed: freezed == onPressed ? _self.onPressed : onPressed // ignore: cast_nullable_to_non_nullable
as VoidCallback?,path: null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as SubmitButtonPosition,icon: freezed == icon ? _self.icon : icon // ignore: cast_nullable_to_non_nullable
as IconData?,
  ));
}

}



/// @nodoc


class _SubmitButtonData implements SubmitButtonData {
  const _SubmitButtonData({required this.text, required this.onPressed, required this.path, required this.position, this.icon});
  

@override final  String? text;
/// Callback invoked when the form (or a part of it) is submitted. This is
/// triggered by the [SubmitButton] or any field configured to submit.
@override final  VoidCallback? onPressed;
/// If not empty, submission validation will be scoped to the node at
/// this path, and its children.
///
/// This is used for validating only a specific section of a larger form.
@override final  String path;
@override final  SubmitButtonPosition position;
@override final  IconData? icon;

/// Create a copy of SubmitButtonData
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SubmitButtonDataCopyWith<_SubmitButtonData> get copyWith => __$SubmitButtonDataCopyWithImpl<_SubmitButtonData>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SubmitButtonData&&(identical(other.text, text) || other.text == text)&&(identical(other.onPressed, onPressed) || other.onPressed == onPressed)&&(identical(other.path, path) || other.path == path)&&(identical(other.position, position) || other.position == position)&&(identical(other.icon, icon) || other.icon == icon));
}


@override
int get hashCode => Object.hash(runtimeType,text,onPressed,path,position,icon);

@override
String toString() {
  return 'SubmitButtonData(text: $text, onPressed: $onPressed, path: $path, position: $position, icon: $icon)';
}


}

/// @nodoc
abstract mixin class _$SubmitButtonDataCopyWith<$Res> implements $SubmitButtonDataCopyWith<$Res> {
  factory _$SubmitButtonDataCopyWith(_SubmitButtonData value, $Res Function(_SubmitButtonData) _then) = __$SubmitButtonDataCopyWithImpl;
@override @useResult
$Res call({
 String? text, VoidCallback? onPressed, String path, SubmitButtonPosition position, IconData? icon
});




}
/// @nodoc
class __$SubmitButtonDataCopyWithImpl<$Res>
    implements _$SubmitButtonDataCopyWith<$Res> {
  __$SubmitButtonDataCopyWithImpl(this._self, this._then);

  final _SubmitButtonData _self;
  final $Res Function(_SubmitButtonData) _then;

/// Create a copy of SubmitButtonData
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? text = freezed,Object? onPressed = freezed,Object? path = null,Object? position = null,Object? icon = freezed,}) {
  return _then(_SubmitButtonData(
text: freezed == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String?,onPressed: freezed == onPressed ? _self.onPressed : onPressed // ignore: cast_nullable_to_non_nullable
as VoidCallback?,path: null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as SubmitButtonPosition,icon: freezed == icon ? _self.icon : icon // ignore: cast_nullable_to_non_nullable
as IconData?,
  ));
}


}

// dart format on
